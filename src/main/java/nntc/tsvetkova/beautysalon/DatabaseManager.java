package nntc.tsvetkova.beautysalon;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.prefs.Preferences;

public class DatabaseManager {
    private static String URL;
    private static String USER;
    private static String PASSWORD;
    private static String SCHEMA;

    private Preferences prefs;

    private Connection connection;

    // конструктор
    // создали для инициализации prefs на уровне всего класса
    public DatabaseManager() {
        prefs = Preferences.userNodeForPackage(DesktopApplication.class);
    }

    // Метод для подключения к базе данных
    public void connect() throws SQLException {

        URL = String.format(
                "jdbc:postgresql://%s:%s/%s?currentSchema=%s",
                prefs.get("subdAddress", "localhost"),
                prefs.get("subdPort", "5432"),
                prefs.get("subdDbname", "postgres"),
                prefs.get("subdSchema", "public")
        );
        USER = prefs.get("subdUser", "postgres");
        PASSWORD = prefs.get("subdPassword", "postgres");
        SCHEMA = prefs.get("subdSchema", "public");

        connection = DriverManager.getConnection(URL, USER, PASSWORD);
        System.out.println("Успешно подключено к базе данных.");
    }

    // Метод для отключения от базы данных
    public void disconnect() {
        if (connection != null) {
            try {
                connection.close();
                System.out.println("Соединение с базой данных закрыто.");
            } catch (SQLException e) {
                System.out.println("Ошибка при закрытии соединения: " + e.getMessage());
                // Показываем модальное окно с ошибкой
                Platform.runLater(() -> ErrorDialog.showError("Ошибка при закрытии соединения: ", e.getMessage()));
            }
        }
    }

    // Метод развёртывания таблиц базы данных
    public void ensureTablesExists() {
        String ddlQueries = String.format("""
                    CREATE TABLE user36.service (
                    	"name" varchar NOT NULL,
                        id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
                    	price float4 NULL,
                    	CONSTRAINT service_pk PRIMARY KEY (id);
                    	
                        CREATE TABLE IF NOT EXISTS %s."storage" (
                    	id int GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"name" varchar NULL,
                    	price float4 NULL,
                    	quantity int NULL,
                    	CONSTRAINT storage_pk PRIMARY KEY (id)
                    );
                        CREATE TABLE IF NOT EXISTS %s.worker (
                    	id int GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"name" varchar NOT NULL,
                    	email varchar NOT NULL,
                    	CONSTRAINT worker_pk PRIMARY KEY (id),
                    	CONSTRAINT worker_unique UNIQUE (email)
                    );
                        CREATE TABLE IF NOT EXISTS %s."admin" (
                    	id int GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"name" varchar NULL,
                    	email varchar NOT NULL,
                    	CONSTRAINT admin_pk PRIMARY KEY (id),
                    	CONSTRAINT admin_unique UNIQUE (email)
                    );
                        CREATE TABLE IF NOT EXISTS %s.client (
                    	id int GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"name" varchar NULL,
                    	email varchar NULL,
                    	CONSTRAINT client_pk PRIMARY KEY (id),
                    	CONSTRAINT client_unique UNIQUE (email)
                    );
                        CREATE TABLE IF NOT EXISTS %s.appointment (
                    	id int4 GENERATED ALWAYS AS IDENTITY NOT NULL,
                    	"time" time NOT NULL,
                    	"date" date NOT NULL,
                    	worker int4 NULL,
                    	client int4 NULL,
                    	service int4 NULL,
                    	"storage" int4 NULL,
                    	CONSTRAINT appointment_pk PRIMARY KEY (id),
                    	CONSTRAINT appointment_client_fk FOREIGN KEY (client) REFERENCES %s.client(id),
                    	CONSTRAINT appointment_service_fk FOREIGN KEY (service) REFERENCES %s.service(id) ON DELETE RESTRICT,
                    	CONSTRAINT appointment_storage_fk FOREIGN KEY ("storage") REFERENCES %s."storage"(id) ON DELETE SET NULL,
                    	CONSTRAINT appointment_worker_fk FOREIGN KEY (worker) REFERENCES %s.worker(id) ON DELETE SET NULL
                    );
                """, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA);

        String dmlQueries = String.format("""
                    INSERT INTO %s.service ("name", price) VALUES
                    ('Массаж', 500),
                    ('Окраска', 5600),
                    ('Кератин для волос', 9000);
                
                    INSERT INTO %s."storage" ("name", price, quantity) VALUES
                    ('Масло для массажа', 15.99, 50),
                    ('Крем для рук', 25.50, 30),
                    ('Краска для волос Estel', 10.75, 100),
                    
                    INSERT INTO %s.worker ("name", email) VALUES
                    ('Анна Иванова', 'anna.ivanova@example.com'),
                    ('Мария Петрова', 'maria.petrova@example.com'),
                    ('Василина Сидорова', 'vasilina.sidorova@example.com');
                
                    INSERT INTO %s."admin" ("name", email) VALUES
                    ('Ольга Кузнецова', 'olga.kuznetsova@example.com');
                    
                    INSERT INTO %s.client ("name", email) VALUES
                    ('Анна Сергеева', 'anna.sergeeva@example.com'),
                    ('Феврония Федорова', 'fevronia.fedorova@example.com'),
                    ('Елена Николаева', 'elena.nikolaeva@example.com');
                
                   INSERT INTO %s.appointment ("time", "date", worker, client, service, "storage") VALUES
                   ('10:00:00', '2023-10-01', 1, 1, 1, 1),
                   ('14:30:00', '2023-10-02', 2, 2, 2, 2),
                   ('09:00:00', '2023-10-03', 3, 3, 3, NULL);
                
                
                """, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA, SCHEMA);


        try (Statement statement = connection.createStatement()) {
            statement.execute(ddlQueries);
            statement.execute(dmlQueries); // Если нужно, то можно и DML запросы здесь запустить
            System.out.println("Проверка структуры базы данных завершена.");
        } catch (SQLException e) {
            System.out.println("Ошибка при проверке/создании таблицы: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при проверке/создании таблицы: ", e.getMessage()));
        }
    }

    public void serviceInsertData(String name, Float price) {
        String query = String.format("INSERT INTO %s (name, price) VALUES (?, ?, ?)",
                SCHEMA.concat(".service"));

        try (var preparedStatement = connection.prepareStatement(query)) {
            preparedStatement.setString(1, name);
            preparedStatement.setObject(3, price, java.sql.Types.FLOAT); // Используем setObject для работы с Float

            int rowsInserted = preparedStatement.executeUpdate();
            System.out.println("Добавлено строк: " + rowsInserted);
        } catch (SQLException e) {
            System.out.println("Ошибка при вставке данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при вставке данных: ", e.getMessage()));
        }
    }


    public void serviceUpdateData(Integer id, String name, float price) {
        String query = String.format("UPDATE %s SET name='%s', WHERE id=%d", SCHEMA.concat(".service"), name, id);

        System.out.println("QUERY:");
        System.out.println(query);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsUpdated = preparedStatement.executeUpdate();
            System.out.println("Обновлено строк: " + rowsUpdated);
        } catch (SQLException e) {
            System.out.println("Ошибка при изменении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при изменении данных: ", e.getMessage()));
        }
    }

    public void serviceDeleteData(int id) {
        String query = String.format("DELETE FROM %s WHERE id=%d", SCHEMA.concat(".service"), id);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsDeleted = preparedStatement.executeUpdate();
            System.out.println("Удалено строк: " + rowsDeleted);
        } catch (SQLException e) {
            System.out.println("Ошибка при удалении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при удалении данных: ", e.getMessage()));
        }
    }

     //Пример: Получение данных
     public ObservableList<Service> serviceFetchData() {
         ObservableList<Service> re = FXCollections.observableArrayList();

         String query = String.format("SELECT id, name, price FROM %s", SCHEMA.concat(".service"));

         try (var preparedStatement = connection.prepareStatement(query);
              var resultSet = preparedStatement.executeQuery()) {

             while (resultSet.next()) {
                 // Извлекаем значения из ResultSet
                 int id = resultSet.getInt("id");
                 String name = resultSet.getString("name");
                 Float price = resultSet.getFloat("price"); // Получаем значение price как Float

                 // Добавляем объект Service в список
                 re.add(new Service(id, name, price));
             }

         } catch (SQLException e) {
             System.out.println("Ошибка при выполнении запроса: " + e.getMessage());
             // Показываем модальное окно с ошибкой
             Platform.runLater(() -> ErrorDialog.showError("Ошибка при выполнении запроса: ", e.getMessage()));
         }
         return re;
     }


    public void clientInsertData(String name, String email) {
        String query = String.format("INSERT INTO %s (name, email) VALUES ('%s', '%s')", SCHEMA.concat(".clients"), name, email);
        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsInserted = preparedStatement.executeUpdate();
            System.out.println("Добавлено строк: " + rowsInserted);
        } catch (SQLException e) {
            System.out.println("Ошибка при вставке данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при вставке данных: ", e.getMessage()));
        }
    }

    public void clientUpdateData(Integer id, String name, String email) {
        String query = String.format("UPDATE %s SET name='%s', email='%s' WHERE id=%d", SCHEMA.concat(".client"), name, email, id);

        System.out.println("QUERY:");
        System.out.println(query);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsUpdated = preparedStatement.executeUpdate();
            System.out.println("Обновлено строк: " + rowsUpdated);
        } catch (SQLException e) {
            System.out.println("Ошибка при изменении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при изменении данных: ", e.getMessage()));
        }
    }

    public void clientDeleteData(int id) {
        String query = String.format("DELETE FROM %s WHERE id=%d", SCHEMA.concat(".client"), id);

        try (var preparedStatement = connection.prepareStatement(query)) {
            int rowsDeleted = preparedStatement.executeUpdate();
            System.out.println("Удалено строк: " + rowsDeleted);
        } catch (SQLException e) {
            System.out.println("Ошибка при удалении данных: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при удалении данных: ", e.getMessage()));
        }
    }

    // Пример: Получение данных
    public ObservableList<Client> clientFetchData() {

        ObservableList<Client> re = FXCollections.observableArrayList();

        String query = String.format("SELECT id, name, email FROM %s", SCHEMA.concat(".client"));

        try (var preparedStatement = connection.prepareStatement(query);
             var resultSet = preparedStatement.executeQuery()) {

            while (resultSet.next()) {
                re.add(new Client(resultSet.getInt("id"), resultSet.getString("name"), resultSet.getString("email")));
            }

        } catch (SQLException e) {
            System.out.println("Ошибка при выполнении запроса: " + e.getMessage());
            // Показываем модальное окно с ошибкой
            Platform.runLater(() -> ErrorDialog.showError("Ошибка при выполнении запроса: ", e.getMessage()));
        }
        return re;
    }

}
